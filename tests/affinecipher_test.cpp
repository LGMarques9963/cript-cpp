//
// Created by lorran on 05/02/25.
//
#include <gtest/gtest.h>
#include <stdexcept>
#include "../src/affineCipher.h"
#include <string>

TEST(AffineCipherTest, EncryptDecrypt) {
    const std::string original = "A computer would deserve to be called intelligent if it could deceive a human into believing that it was human. -Alan Turing";;
    const affineCipher cipher;
    constexpr int key = 2894;

    const std::string encrypted = cipher.encryptMessage(key, original);
    const std::string decrypted = cipher.decryptMessage(key, encrypted);

    EXPECT_EQ(original, decrypted);
}

// Test that encryption/decryption of an empty string works correctly.
TEST(AffineCipherTest, EncryptDecryptEmptyString) {
    const affineCipher cipher;
    constexpr int validKey = 2894;
    const std::string original;

    const std::string encrypted = cipher.encryptMessage(validKey, original);
    const std::string decrypted = cipher.decryptMessage(validKey, encrypted);

    EXPECT_EQ(original, decrypted);
}

// Test that an invalid key (one that fails the coprimality check) throws an exception.
TEST(AffineCipherTest, InvalidKeyThrowsException) {
    const affineCipher cipher;
    // 2984 is known to be invalid because it produces a keyA that is not coprime with SYMBOLS.size()
    constexpr int invalidKey = 2984;
    const std::string message = "TEST MESSAGE";

    EXPECT_THROW(cipher.encryptMessage(invalidKey, message), std::invalid_argument);
    EXPECT_THROW(cipher.decryptMessage(invalidKey, message), std::invalid_argument);
}

// Test that a random key generated by getRandomKey() can successfully encrypt and decrypt a message.
TEST(AffineCipherTest, RandomKeyWorks) {
    const affineCipher cipher;
    const int randomKey = cipher.getRandomKey();
    const std::string message = "The quick brown fox jumps over the lazy dog.";

    // This should not throw and decryption should recover the original message.
    const std::string encrypted = cipher.encryptMessage(randomKey, message);
    const std::string decrypted = cipher.decryptMessage(randomKey, encrypted);

    EXPECT_EQ(message, decrypted);
}

// Test that a key generated by getRandomKey() is valid.
TEST(AffineCipherTest, RandomKeyIsValid) {
    const affineCipher cipher;
    const int randomKey = cipher.getRandomKey();

    // Check that the key is valid by attempting to encrypt a message.
    const std::string message = "TEST MESSAGE";
    EXPECT_NO_THROW(cipher.encryptMessage(randomKey, message));
}

// Test that a key generated by getRandomKey() is different each time.
TEST(AffineCipherTest, RandomKeyIsDifferent) {
    const affineCipher cipher;
    const int key1 = cipher.getRandomKey();
    const int key2 = cipher.getRandomKey();

    EXPECT_NE(key1, key2);
}

int main (int argc, char **argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}

